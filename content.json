{"meta":{"title":"俗人","subtitle":"凡事不问","description":"你喜欢独处，却又担心寂寞，于是你爱上一阵又一阵迎面吹来的风","author":"俗人","url":""},"pages":[{"title":"bangumi","date":"2020-05-01T13:32:48.000Z","updated":"2020-06-22T08:14:35.731Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2020-05-01T14:14:36.000Z","updated":"2020-06-22T08:57:02.407Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[脚滑の俗人] 天&nbsp; 人&nbsp; （ 交（发）战（呆） ） 中... bot_ui_ini()","keywords":"关于"},{"title":"分类","date":"2020-04-30T16:00:00.000Z","updated":"2020-06-22T08:54:22.290Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-07T14:30:06.029Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"留言板","date":"2020-05-01T12:17:58.000Z","updated":"2020-06-25T16:02:38.462Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"&lt;h2 align=\"center\">有什么想说的?&lt;/h2> &lt;h2 align=\"center\">有什么想问的?&lt;/h2> 念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2019-11-05T15:33:33.000Z","updated":"2019-11-07T14:30:32.974Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-11-05T15:33:33.000Z","updated":"2019-11-07T14:30:42.237Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2020-05-01T15:33:33.000Z","updated":"2020-06-22T09:00:48.404Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友情链接"},{"title":"music","date":"2019-11-05T15:33:33.000Z","updated":"2019-11-08T02:48:57.055Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-06T12:44:34.880Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-01T12:24:16.000Z","updated":"2020-06-22T08:55:01.931Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-11-05T14:53:25.000Z","updated":"2019-11-07T13:41:01.757Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2019-11-05T15:14:38.000Z","updated":"2019-11-07T13:41:52.063Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: ' 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"学习记录之现代浏览器内部揭秘","slug":"学习记录之现代浏览器内部揭秘","date":"2020-07-16T12:32:59.000Z","updated":"2020-07-17T09:37:39.113Z","comments":true,"path":"post/ed43.html","link":"","permalink":"/post/ed43.html","excerpt":"","text":"老前言了之前也看过浏览器工作原理，不过那时候知识储备还不够，看起来云里雾里，看完也没有总结，一大把的功夫就打水漂了。 今天心血来潮，突然想看看浏览器工作原理，找鸭找，终于找到了我最爱的那种文章。 正是Inside look at modern web browser系列。看完之后，觉得意犹未尽，正好想总结一下，于是就打算写这一篇记录。（通文中其他链接一样，，，进入该链接需要“机缘”） （在看完之后，发现这系列文章在之前的掘金翻译计划中有参与，在遗憾没有第一时间发现的同时，想到能更方便自己平时的浏览，也就释然了。在这里先分享出来，不过我还没怎么看过译版，大家自己评价。） 第一篇、第二篇、第三篇、第四篇 第一篇说明：由于不缺翻译，我打算仅记录个人认为关键的点。 As part 1 of this series, we’ll take a look at core computing terminology and Chrome’s multi-process architecture. 本系列博客的第一篇，讲的是基本术语与Chrome的多进程架构。 If two processes need to talk, they can do so by using Inter Process Communication (IPC). 进程之间通过IPC技术通讯。（文内不特意强调） Chrome的多进程架构： Process and What it controls Browser Controls “chrome” part of the application including address bar, bookmarks, back and forward buttons. Also handles the invisible, privileged parts of a web browser such as network requests and file access. Renderer Controls anything inside of the tab where a website is displayed. Plugin Controls any plugins used by the website, for example, flash. GPU Handles GPU tasks in isolation from other processes. It is separated into different process because GPUs handles requests from multiple apps and draw them in the same surface. 主要用到的是：浏览器进程、渲染进程、插件进程、GPU进程。 浏览器进程：控制应用中的 “Chrome” 部分，包括地址栏，书签，回退与前进按钮。以及处理 web 浏览器不可见的特权部分，如网络请求与文件访问。 渲染进程：控制标签页内网站展示。 插件进程： 控制站点使用的任意插件，如 Flash。 GPU进程：处理独立于其它进程的 GPU 任务。GPU 被分成不同进程，因为 GPU 处理来自多个不同应用的请求并绘制在相同表面。 还有些进程，但不那么关心，如扩展（Extension ）进程、工具（utility）进程。 简单总结一下浏览器多进程架构的优点： 通过开启多个渲染进程，使得标签页之间相对独立，一般不会因一个标签页崩溃而整个程序崩溃。（不一般是指内存不够时，相同站点的标签页会由同一个渲染进程负责，当然，此时开启进程的数量也会有限制。） 安全性与封闭性（sandbox）好。浏览器通过操作系统提供的方法，限制某些进程的权限。例如，限制渲染进程对文件的访问权限。 浏览器的架构正在更新：下一个方向是通过将模块服务化，自适应设备的资源，聚合成一个或分解成多个进程。（待考究是否已经更改） Chrome针对安全攻击的优化：即不同站点的页面由不同的渲染进程展示，即使他们在同一个tab（如利用iframe）。 第二篇 In the previous post, we looked at how different processes and threads handle different parts of a browser. In this post, we dig deeper into how each process and thread communicate in order to display a website. 第二篇，讲浏览器是怎样通过协调进程与线程，来展示页面的。 接下来的整体流程是真的清晰，因为它是从浏览器的角度来说的。 What happens in navigation——从输入url到呈现页面第一步：处理输入 When a user starts to type into the address bar, the first thing UI thread asks is “Is this a search query or URL?”. 这里的UI线程是浏览器进程的一部分，负责处理标签页外的UI。 用户的输入先由它这样处理，因为Chrome的地址栏同样是搜索栏。 第二步：开始导航 When a user hits enter, the UI thread initiates a network call to get site content. 用户确认输入以后，UI线程通知浏览器进程中的网络线程（现在好像网络线程从浏览器进程中独立出来了，不过本记录仍保留原文的描述）以获取网络资源。此时UI线程将标签页左侧设置成旋转的Loading。 而网络线程，就采用各种协议请求资源。（浏览器缓存的内容与方式决定了网络线程发送请求的与否） 此时，若网络线程收到服务端发过来301的重定向状态码，则会通知UI线程更改地址栏的同时（仅更改地址），自己开始重新请求。 第三步：处理响应当服务器返回响应时，为了确定数据类型，浏览器进程的网络线程可能会阅读响应体中的字节流。即响应头的Content-Type字段丢失或者错误时，网络线程就会进行MIME Type sniffing。 The definition of how browsers should interpret media types and figure out what to do with content that doesn’t have a valid one 当确定了响应的类型，例如HTML文件（输了URL肯定先要HTML），浏览器进程的网络线程会把数据送给渲染进程。 （脱离我们的导航场景，当响应数据为zip等其他非渲染页面要用的文件时，网络线程会将数据传给下载管理器（download manager）） 在网络线程传数据给其他模块之前，会进行一些安全检测，如safeBrowsing和CORB。 第四步：准备渲染进程当检查完毕，并且网络线程确定浏览器应该导航至请求的网站时，网络线程通知UI线程数据已经准备完毕，经由UI线程的手，准备渲染进程。 由于网络线程是需要等待响应的（可能会数百毫秒），此处应用了一个优化。 UI线程实际上会在网络线程发出请求的同时寻找或开启一个渲染进程，不出意外，当网络线程接收到响应式，渲染进程应该已经准备好了。（但当响应是跨站重定向时，将不会使用准备好的进程，而是重新开启新的进程，整个过程也会慢一些。） 第五步：提交导航当渲染进程和数据都准备好，浏览器进程就会向渲染进程提交本次导航，附带响应首部（当然还有数据，由网络线程和渲染进程直接建立数据通道的方式传输）。一旦浏览器进程接收到渲染进程对此次提交的确认，导航就已经完成了，而页面加载阶段开始。 此时，浏览器的地址栏会进行更新，如显示安全标志和网站信息等等。浏览历史（保存在磁盘上）也会更新以保证前进后退的使用（此时Loading并未停止）。 第六步：页面加载（以上是导航的过程，接下来就是渲染进程负责的页面加载了。但页面加载也挺复杂，所以作者将页面加载放在了第三篇。） 额外的步骤：初始化加载完成跳过页面加载，渲染进程在加载“完成”之后，会通知浏览器进程（所有onLoad事件已经完成时），此时浏览器进程的UI线程才会停止旋转Loading。 上面的“完成”打引号是因为JS可能会加载额外的资源并导致渲染新的视图。 重新导航以上是第一次输入URL的导航过程。重新导航至其他网站，会在之前的基础上多出一个处理beforeunload事件的过程（JS代码，当然是运行在渲染进程）。另外，如其名，这个过程是在导航新页面之前的。 （导航至其他网站有两种方式，一是输入URL，二是JS和链接。两种方式导致的区别只在于浏览器进程与渲染进程中，谁是主动通信的一方。） beforeunload事件处理之后，就会启动新的渲染进程，旧的进程则处理像unload这样的事件。更多详细信息可参阅 an overview of page lifecycle states 和 the Page Lifecycle API. 如果有Service Worker虽然我对Service Worker还不了解，但不耽误我理解浏览器对它的处理。 当浏览器发现Service Worker的存在时，并且新的导航被Service Worker所关联（或者说注册），那么将会有一个渲染进程来执行Service Worker的代码，并由其决定究竟是使用缓存还是发送网络请求。 （由于等待Service Worker确认是否发起网络请求，所以会有延迟，Chrome对此也做了优化，即Service Worker开始的同时，标记并发起一些请求，这些请求可由服务器来决定响应的具体内容。） It marks these requests with a header, allowing servers to decide to send different content for these requests; for example, just updated data instead of a full document. 第三篇第三篇主要介绍了第二篇中的第六步。 The renderer process’s core job is to turn HTML, CSS, and JavaScript into a web page that the user can interact with. 渲染进程的主要职责，就是将HTML，CSS，JS转化成一个用户可以交互的网页。 渲染进程内包含的线程 主线程：负责处理发送到客户端（User）的主要代码 合成线程：处理合成任务 栅格化线程：处理栅格化任务 工作线程：如果启用web worker或service worker，部分js将由工作线程处理 页面加载，启动解析 Parsing an HTML document into a DOM is defined by the HTML Standard. 根据HTML 标准将HTML解析成DOM。 子资源加载网站中使用到的额外资源，如图片，CSS，JS等。HTML解析器在遇到这些资源时，会生成令牌（tokens），并在构建DOM的过程中由预加载扫描器（preload scanner）处理，最终通知（send requests to the network thread）浏览器进程中的网络线程以发送请求。 HTML中的ScriptHTML解析是会被阻塞的。被script标签甚至是CSS样式。 （当Script标签内部访问了CSS，而该CSS是外部导入，需要下载的，那么此时就需要等待CSS下载完成后再执行JS代码，所以可以说是被CSS阻塞） 样式计算在主线程（别忘了几个线程的名字）解析完DOM后（不被阻塞），会开始计算样式。 布局同样，由主线程根据DOM和样式来生成布局树。它是一个类似于DOM，保存着所有位置关系的树形结构。（所有位置信息，所以overflow: hidden的节点和伪元素都会包含在内，而display: none的节点，因为它没有位置信息，所以不在内。） 绘制为了绘制界面，还需要计算一个绘制顺序——绘制记录。就像： Paint record is a note of painting process like “background first, then text, then rectangle”. 合成按理来说，知道以上所有的信息（DOM、样式、布局树、绘制记录）之后，就可以生成页面了，U1S1，确实，Chrome刚发布的时候确实是这样的，但后面做了优化，那就是合成。 Compositing is a technique to separate parts of a page into layers, rasterize them separately, and composite as a page in a separate thread called compositor thread. 合成呢，是将网页分成很多层（方便处理层叠和3D），让他们分开栅格化（不合成的话，生成页面栅格化就完事儿了），最后在合成线程中合成他们。 （层叫起来拗口死了，后面叫他图层） 说起来简单，但合成呢，也不是一次性把所有东西都合成的，毕竟那样分开还有什么意义。 这里举个栗子。当滚动发生的时候，之前的图层已经栅格化了，所以只要合成一个新的图像（frame，帧，画面-&gt;图像）就行了。 ？？？什么乱七八糟的 奥，这里的图像是并不是我们想象中的一个很大的图像，概念后面再说，反正它并不一定是一个屏幕那么大。所以说滚动了只要合成一个图像就完事儿了。（动画也是这么搞） 那么网页分成很多图层？怎么个分法？ 奥，这还是主线程干的活。 通过布局树来生成图层树。那不是没我们开发者什么事儿？那到不是，还是能干点事儿的。 If certain parts of a page that should be separate layer (like slide-in side menu) is not getting one, you can hint to the browser by using will-change attribute in CSS. 如果你觉得他可以多分点，那你就通过will-change属性叫他分。 （物极必反，图层分多了，效率还不如不合成呢，想了解的戳 Stick to Compositor-Only Properties and Manage Layer Count） 合成线程干活啦图层树生成完了，绘制记录也有了，那就该栅格化线程出场了。主线程将这俩信息给合成线程，合成线程就把图层全部都给栅格化线程。 ？？？合成线程干了个啥，打酱油？ 原来图层太大啦，由合成线程操刀，把他都分成小片（divides them into tiles）。 然鹅，一个图层分出的小片却可以组合成不止一个图层，因为有： multiple tilings for different resolutions to handle things like zoom-in action 然后栅格化线程，将这些小片栅格化，就存进了GPU内存里。其中，在视口内或附近的小片会被优先栅格化。 当小片被栅格化之后，合成线程就又跳出来了。 compositor thread gathers tile information called draw quads to create a compositor frame. 他会收集记录小片信息的draw quads，然后生成合成图像。 Draw quads Contains information such as the tile’s location in memory and where in the page to draw the tile taking in consideration of the page compositing. Compositor frame A collection of draw quads that represents a frame of a page. 合成图像生成之后，就被提交给浏览器进程，同时，合成线程又能生成其他的图像（为页面或为浏览器UI）。浏览器进程又把合成图像扔给GPU，让它显示（可能是权限问题，所以要经由浏览器进程之手）。 像刚刚说的，出现滚动事件，合成线程合成新的图像就完事儿了。 （合成说起来感觉很复杂，可是这都不是主线程干的事儿，所以不需要像主线程那样会被HTML、CSS、JS耽搁，除非要重新生成图层树。） 更新渲染是costly的我们常说回流和重绘，就是由于浏览器高花销的渲染流程。（这里的高花销并不是指其占用的资源很多，而是指在渲染的过程中，主线程的每个结果都是根据之前得出的结果生成的。） 第四篇（待续）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Record","slug":"Record","permalink":"/tags/Record/"},{"name":"Web Broswer","slug":"Web-Broswer","permalink":"/tags/Web-Broswer/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"他是谁?","slug":"他是谁","date":"2020-07-16T11:55:18.000Z","updated":"2020-07-17T09:09:12.622Z","comments":true,"path":"post/7161.html","link":"","permalink":"/post/7161.html","excerpt":"","text":"有个人一直在教你他让你热爱生活 喊你按时吃饭 总说食物要营养均衡 提醒你坚持锻炼 也说要保持学习，保持思考 得注意天气变更 不能忘了孝顺长辈，帮扶小辈 做人应当互相尊重，乐于助人 不管什么时候都要自尊自爱，善待他人 凡事却别太辛苦，要劳逸结合 不管多急也注意休息，养成好的作息习惯 还要保护视力，做做眼保健操 必须要热爱祖国，自信自强 又说工作是分内，创造价值是根本 时刻要自我提高，自我反省 没事多换位思考，己所不欲，勿施于人 再学学情绪调节，喜怒误事 偶尔也说人生苦短，却乐在其中 他是谁？他是你自个儿。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"/tags/生活/"},{"name":"日常","slug":"日常","permalink":"/tags/日常/"},{"name":"感悟","slug":"感悟","permalink":"/tags/感悟/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"学习记录之React类组件生命周期","slug":"学习记录之React类组件生命周期","date":"2020-07-14T08:11:35.000Z","updated":"2020-07-17T09:09:31.672Z","comments":true,"path":"post/7141.html","link":"","permalink":"/post/7141.html","excerpt":"","text":"老前言了（这篇文章的主要目的是记录，因为我还没到总结的时候。。文中引用的部分都来自于知乎的LeviDing大佬，瑞思拜） Hooks突突突地起飞了，理想中应该是不用学类组件中的生命周期了。 然而现实肯定和理想中的不一样，不然它叫个芽儿的现实。。。那么，生活总要面对，静下心来想想，除了维护以前未重构的业务，类组件还能为我们带来什么？ 首先！面向对象编程全套的软件开发流程诶，搭配面向对象编程的各种项目精细化手段和最佳实践诶。 个人理解，由于函数式编程的局限（暂时？），可能需要很长一段时间，这种编程范式才能传播开，才能在更广的范围内（不仅于前端，如项目管理，开发流程，项目精细化等等）发展并经受住考验。 其次！通过类组件的生命周期，我们能切实的参与进React的渲染机制，再结合React的发展，以多种角度，以不同的高度，利用React进行开发（这就是自我发电式学习吗，那还真是有够好笑的呢（ ๑乛◡乛๑））。 接下来！接下来啊，接下来没有了（阿这，我想不到了，我好菜T-T）。 仨阶段（仨阶段有5个小标题不是常识吗）我先扯个题外话（嗯，我扯题外话一直可以的┓(´_｀)┏）。 类组件中，生命周期出现的意义是什么？（为开发人员提供的，参与进React渲染流程，并能进行干涉的，一种手段？？？待研究）Hooks没有生命周期，难道就没有办法做到类组件能做的事了吗？（待研究） 好！没研究就先回来。 生命周期总览看博客也就图一乐，真要学生命周期害得看图。 这是原汁原味的图，按照官方的划分，我们从三个阶段依次来理解。 在其中，我们会讲到废弃的生命周期，因为这不仅能让我们了解React生命周期的发展，还能让我们更好的理解React的渲染流程（在这看渲染流程也就图一乐，真想了解透彻害得看Fiber啥的，不过结合起来也不错哦|ू･ω･` )）。 挂载阶段挂载阶段，就是将组件挂载到DOM树上，需要经过如下： constructor getDerivedStateFromProps UNSAVE_componentWillMount render （React Updates DOM and refs） componentDidMount 几个过程，其中括号裹住的并不是真实的生命周期，可以理解为衔接两个生命周期的中间过程。（未使用有序列表是因为暂时还未确认实际上的调用顺序是否是这样的，不过至少设计上是这样的。） 此处需要引用大佬的见解： constructor组件的构造函数，第一个被执行。如果在组件中没有显示定义它，则会拥有一个默认的构造函数。如果我们显示定义构造函数，则必须在构造函数第一行执行 super(props)，否则我们无法在构造函数里拿到 this，这些都属于 ES6 的知识。 在构造函数中，我们一般会做两件事： 初始化 state 对自定义方法进行 this 的绑定 constructor(props) { super(props); this.state = { width, height: 'atuo', } this.handleChange1 = this.handleChange1.bind(this); this.handleChange2 = this.handleChange2.bind(this); } getDerivedStateFromProps使用方式： //static getDerivedStateFromProps(nextProps, prevState) class Example extends React.Component { static getDerivedStateFromProps(props, state) { //根据 nextProps 和 prevState 计算出预期的状态改变，返回结果会被送给 setState // ... } } 新的 getDerivedStateFromProps 是一个静态函数，所以不能在这函数里使用 this，简单来说就是一个纯函数。也表明了 React 团队想通过这种方式防止开发者滥用这个生命周期函数。每当父组件引发当前组件的渲染过程时，getDerivedStateFromProps 会被调用，这样我们有一个机会可以根据新的 props 和当前的 state 来调整新的 state。 这个函数会返回一个对象用来更新当前的 state，如果不需要更新可以返回 null。这个生命周期函数用得比较少，主要用于在重新渲染期间手动对滚动位置进行设置等场景中。该函数会在挂载时，在更新时接收到新的 props，调用了 setState 和 forceUpdate 时被调用。 我会这样理解：这个getDerivedStateFromProps生命周期在两个阶段都会被调用。 挂载阶段的constructor之后； 更新阶段的props变化之后，通过setState更改状态之后，使用forceUpdate更新之后。 在挂载阶段，个人不太清楚它的应用场景。它既然设计成，并且官方也推荐其，仅用来处理单一更新来源的，随着props更改而更改的状态，就不该在挂载阶段被触发（感觉这个生命周期是需求——根据props更新state，与实际——实现异步渲染以提高应用的交互性，所折中的一种产物，理解有误还望大佬提点）； 更新阶段，就，就请先往下康。。 新的 getDerivedStateFromProps 实际上与 componentDidUpdate 一起取代了以前的 UNSAFE_componentWillReceiveProps 函数。UNSAFE_componentWillReceiveProps 也是考虑到因为父组件引发渲染可能要根据 props 更新 state 的需要而设立的。 这里的UNSAFE_componentWillReceiveProps即是ReactV16.4之后被废弃，并在React V17出来之后将不再支持的生命周期。 （对于这段文字，个人认为，componentDidUpdate与componentDidMount是起相同的作用的，前者只是多了用来防止无限循环的参数和对另一个生命周期，getSnapshotBeforeUpdate的支持而已，有误望指出） UNSAVE_componentWillMountUNSAFE_componentWillMount() 在挂载之前被调用。它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染。通常，我们建议使用 constructor() 来初始化 state。避免在此方法中引入任何副作用或订阅。如遇此种情况，请改用 componentDidMount()。 此方法是服务端渲染唯一会调用的生命周期函数。UNSAFE_componentWillMount() 常用于当支持服务器渲染时，需要同步获取数据的场景。 正如大佬所说，在同步渲染中，UNSAVE_componentWillMount中处理各种是没有问题的，但由于框架的发展，需要优化渲染机制，所以以前的这个生命周期函数无法按照期望运行（此处可以去了解一下React的更新，Fiber的引入等等——指我自己，因为我还没怎么看 ＿|￣|●）。 继续： render这是 React 中最核心的方法，class 组件中唯一必须实现的方法。 当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一： 原生的 DOM，如 div React 组件 数组或 Fragment Portals（插槽） 字符串和数字，被渲染成文本节点 Boolean 或 null，不会渲染任何东西 render() 函数应该是一个纯函数，里面只做一件事，就是返回需要渲染的东西，不应该包含其它的业务逻辑，如数据请求，对于这些业务逻辑请移到 componentDidMount 和 componentDidUpdate 中。 （这里大佬应该是忘记打引号了，实际上应该都是先，生成虚拟DOM。。不过意思到了就行，个人认为第一个类型改为”React元素“会更好，小声bb） componentDidMountcomponentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅 你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。 请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理 这里第二段中，“它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前”，不是很能理解到（意思是在componentDidMount调用setState()，会跳过Reconciliation的过程吗，不会被操作中断，直到第二次渲染结束？还是怎么个过程呢。。。），插眼。 更新阶段更新即组件需要重新渲染的阶段，触发的原因可能有props更改，内部状态通过setState更改，发生了forceUpdate。每次更新需要经过的过程是： UNSAFE_componentWillReceiveProps getDerivedStateFromProps shouldComponentUpdate UNSAFE_componentWillUpdate render getSnapshotBeforeUpdate （React Updates DOM and refs） componentDidUpdate 写成这样的原因同上，同样引用大佬的解读： UNSAFE_componentWillReceivePropsUNSAFE_componentWillReceiveProps 是考虑到因为父组件引发渲染可能要根据 props 更新 state 的需要而设立的。UNSAFE_componentWillReceiveProps 会在已挂载的组件接收新的 props 之前被调用。如果你需要更新状态以响应 prop 更改（例如，重置它），你可以比较 this.props 和 nextProps 并在此方法中使用 this.setState() 执行 state 转换。 如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。在挂载过程中，React 不会针对初始 props 调用 UNSAFE_componentWillReceiveProps()。组件只会在组件的 props 更新时调用此方法。调用 this.setState() 通常不会触发 UNSAFE_componentWillReceiveProps()。 ”如果父组件导致组件重新渲染“，这里说的是父组件重新渲染。。。罢？ getDerivedStateFromProps这个方法在挂载阶段已经讲过了，这里不再赘述。记住该函数会在挂载时，在更新时接收到新的 props，调用了 setState 和 forceUpdate 时被调用。它与 componentDidUpdate 一起取代了以前的 UNSAFE_componentWillReceiveProps 函数。 shouldComponentUpdateshouldComponentUpdate(nextProps, nextState) { //... } 它有两个参数，根据此函数的返回值来判断是否进行重新渲染，true 表示重新渲染，false 表示不重新渲染，默认返回 true。注意，首次渲染或者当我们调用 forceUpdate 时并不会触发此方法。此方法仅用于性能优化。 因为默认是返回 true，也就是只要接收到新的属性和调用了 setState 都会触发重新的渲染，这会带来一定的性能问题，所以我们需要将 this.props 与 nextProps 以及 this.state 与 nextState 进行比较来决定是否返回 false，来减少重新渲染，以优化性能。请注意，返回 false 并不会阻止子组件在 state 更改时重新渲染。 这里指的是父组件中的shouldComponentUpdate并不会递归地影响子组件的渲染。 但是官方提倡我们使用内置的 PureComponent 来减少重新渲染的次数，而不是手动编写 shouldComponentUpdate 代码。PureComponent 内部实现了对 props 和 state 进行浅层比较。 如果 shouldComponentUpdate() 返回 false，则不会调用 UNSAFE_componentWillUpdate()，render() 和 componentDidUpdate()。官方说在后续版本，React 可能会将 shouldComponentUpdate 视为提示而不是严格的指令，并且，当返回 false 时，仍可能导致组件重新渲染。 这应该也是官方推荐使用内置实现的PureComponent的理由，当shouldComponentUpdate逐渐成为一种决定是否渲染的权重时，可能会有新的变动。 UNSAFE_componentWillUpdate当组件收到新的 props 或 state 时，会在渲染之前调用 UNSAFE_componentWillUpdate()。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。但是你不能此方法中调用 this.setState()。在 UNSAFE_componentWillUpdate() 返回之前，你也不应该执行任何其他操作（例如，dispatch Redux 的 action）触发对 React 组件的更新。 通常，此方法可以替换为 componentDidUpdate()。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 getSnapshotBeforeUpdate() 中。 render这个方法在挂载阶段已经讲过了，这里不再赘述。 这俩没什么好说的，大概。 ⊙(・◇・)？ getSnapshotBeforeUpdategetSnapshotBeforeUpdate(prevProps, prevState) { //... } getSnapshotBeforeUpdate 生命周期方法在 render 之后，在更新之前（如：更新 DOM 之前）被调用。给了一个机会去获取 DOM 信息，计算得到并返回一个 snapshot，这个 snapshot 会作为 componentDidUpdate 的第三个参数传入。如果你不想要返回值，请返回 null，不写的话控制台会有警告。 并且，这个方法一定要和 componentDidUpdate 一起使用，否则控制台也会有警告。getSnapshotBeforeUpdate 与 componentDidUpdate 一起，这个新的生命周期涵盖过时的 UNSAFE_componentWillUpdate 的所有用例。 getSnapshotBeforeUpdate(prevProps, prevState) { console.log('#enter getSnapshotBeforeUpdate'); return 'foo'; } componentDidUpdate(prevProps, prevState, snapshot) { console.log('#enter componentDidUpdate snapshot = ', snapshot); } 上面这段代码可以看出来这个 snapshot 怎么个用法，snapshot 乍一看还以为是组件级别的某个“快照”，其实可以是任何值，到底怎么用完全看开发者自己，getSnapshotBeforeUpdate 把 snapshot 返回，然后 DOM 改变，然后 snapshot 传递给 componentDidUpdate。 官方给了一个例子，用 getSnapshotBeforeUpdate 来处理 scroll，并且说明了通常不需要这个函数，只有在重新渲染过程中手动保留滚动位置等情况下非常有用，所以大部分开发者都用不上，也就不要乱用。 阿巴阿巴，懂乐懂乐。 componentDidUpdatecomponentDidUpdate(prevProps, prevState, snapshot) { //... } componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法。在这个函数里我们可以操作 DOM，和发起服务器请求，还可以 setState，但是注意一定要用 if 语句控制，否则会导致无限循环。 componentDidUpdate(prevProps) { // 典型用法（不要忘记比较 props）： if (this.props.userID !== prevProps.userID) { this.fetchData(this.props.userID); } } 如果组件实现了 getSnapshotBeforeUpdate() 生命周期，则它的返回值将作为 componentDidUpdate() 的第三个参数 snapshot 参数传递。否则此参数将为 undefined。 卸载阶段啊啊啊啊啊，总算要完了。 componentWillUnmount 是的，没错，只剩最后一个生命周期了，奥利给。 componentWillUnmountcomponentWillUnmount() 会在组件卸载及销毁之前直接调用。我们可以在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。注意不要在这个函数里调用 setState()，因为组件不会重新渲染了。 这里大佬附上了两个不常用的生命周期，有空也可以过一遍。 详细使用示例请见：React 官方文档[3] static getDerivedStateFromError()static getDerivedStateFromError(error) { //... } 此生命周期会在后代组件抛出错误后被调用。它将抛出的错误作为参数，并返回一个值以更新 state。getDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。如遇此类情况，请改用 componentDidCatch()。 componentDidCatch()componentDidCatch(error, info) { //... } 此生命周期在后代组件抛出错误后被调用。它接收两个参数： error —— 抛出的错误。 info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。 componentDidCatch() 会在“提交”阶段被调用，因此允许执行副作用。它应该用于记录错误之类的情况： 如果发生错误，你可以通过调用 setState 使用 componentDidCatch() 渲染降级 UI，但在未来的版本中将不推荐这样做。可以使用静态 getDerivedStateFromError() 来处理降级渲染。 废弃总结上面介绍了一共三个废弃的旧生命周期，即有UNSAFE_前缀的 UNSAFE_componentWillMount UNSAFE_componentWillReceiveProps UNSAFE_componentWillUpdate 废弃的最关键原因，应该是： 在 React V16.0 之前，React 是同步渲染的，而在 V16.0 之后 React 更新了其渲染机制，是通过异步的方式进行渲染的，在 render 函数之前的所有函数都有可能被执行多次。 就这就这就这？感觉哪里不对，奥，这只是生命周期啊，那没事了。 (:ι」∠)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"React_Lifecycle_V16.4","slug":"React-Lifecycle-V16-4","permalink":"/tags/React-Lifecycle-V16-4/"},{"name":"React.js","slug":"React-js","permalink":"/tags/React-js/"},{"name":"Record","slug":"Record","permalink":"/tags/Record/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"理解JavaScript的重要概念","slug":"理解JavaScript的重要概念","date":"2020-06-29T16:08:31.000Z","updated":"2020-07-17T09:08:19.382Z","comments":true,"path":"post/d5b6.html","link":"","permalink":"/post/d5b6.html","excerpt":"","text":"前言​ 既然执行上下文，环境记录，作用域，作用域链，词法环境，变量环境，闭包等是JS的重要概念，那么它们对于我们来说，是不陌生的。 ​ 然而大多数人在学习前端的过程中，很少也很难从语言规范入手，所以这些概念是属于早接触，晚理解的那一类。 ​ 然而，整个学习过程中，本人虽然也尝试深入理解了这些概念，但并没有达到理想的效果（总有人在概念后面打括号，将一些概念划等号，不告诉我们为什么没问题，问题是不同的人划的等号还不同？！(╯‵□′)╯︵┻━┻），为此，我决定根据ECMAScript2021，来进一步地理解它们。 规范类型（Specification Types）在讲以上的重要概念之前，我们需要先了解这么一个概念——规范类型。 ​ 引用规范中的话： A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. ​ 规范类型，对应于算法中用于描述ECMAScript语言结构和语言类型的语义的元值。 ​ 简单来说，就是一些不可拆分的数据结构（个人理解，有误望指出），而这些数据结构，被用来描述ECMAScript这一门语言。其中包括我们熟知的列表（List），指针（Reference），集合（Set）等等，其中这里需要强调的也是规范中常用的一种数据类型，叫作记录（Record）。 记录（Record）​ 同样，引用规范中的介绍： The Record type is used to describe data aggregations within the algorithms of this specification. ​ 在本规范中，记录，是用来描述算法中数据的集合（集合体）的。 记录的值在形式上类似于我们的键值对，由字段与字段的值组成。其中字段总是形如[[Field]]。 关于规范类型和记录，就先扯这么多，大致理解前者是描述语言的元数据类型，后者是前者中的一种就先够了。我们后面会提的环境记录，就属于记录的一种。 执行上下文（Execution Contexts）——也就是作用域（Scope）这一概念在JS中的体现首先我们先来解释一下这个标题。为什么说作用域这一概念在JS中的体现是执行上下文呢？ 作用域这一概念，本就不是，也不需要由ECMAScript来定义。它的意义百度一下就能知道： 作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。 MDN中也明确地写到，Scope： The current context of execution. 只是作用域这个概念相比于执行上下文来说，前者更偏向于表示代码中名称（标识符）的可达性，而后者更偏向于表示规范中跟踪代码运行的一个程式（device）。后者的意义显得更加完整一些，当然，实际生活中我们使用的时候不一定用的那么得严谨。 接下来我们先来搞清楚执行上下文，再来说作用域链。 那么，执行上下文到底是个什么东西？扯一个题外话为什么我们要理解执行上下文这个概念而不是其他？（一些小伙伴对其他概念可能也有这样的疑问，道理是一样的） ​ 我们都知道，由于流控制语句与函数调用的关系，程序并不是单纯的从上往下执行的。所以要想正确的执行代码，就需要将代码转化为正确的机器码。而这，有两种办法，编译与解释，分别对应了两种语言，编译型语言和解释型语言。 ​ 随便一查“JavaScript”，就会看到众多“脚本语言”的字眼。而脚本语言的特点之一，就是解释执行。然而为了解决解释语言解释器低效的问题，浏览器，也就是ECMAScript Implementation，引入Just-in-time编译器（JIT）。从而实现了变量提升等解释型语言难以实现的特性。 ​ 上面说了这么多，和执行上下文有什么关系，为啥要理解执行上下文？？？好吧，一个点是因为JIT是基于执行上下文来实现的。当然还有其他的原因，比如说，为了理解闭包，分析复杂结构代码，或者检查 Bug 等等。不仅能通过执行上下文栈来解决工作中的Bug，还能进一步了解闭包的产生条件，闭包的工作原理等等，所以，执行上下文他。。不香嘛？？？๑乛◡乛๑。（那。。。为什么要理解闭包？因为经常要用并且还老是出Bug啊，此处禁止套娃哈哈，另，下面有闭包的一些适用场景） 回归正题执行上下文是什么？老样子，引用： An execution context is a specification device that is used to track the runtime evaluation of code by an ECMAScript implementation. ​ 有道直译是这样的： 执行上下文是一种规范设备，用于跟踪ECMAScript实现对代码的运行时评估。 ​ 那么，个人理解一下。执行上下文是一种特殊的手段，被用来跟踪不同的ES实现（例如V8引擎、Node.JS）中，代码的运行。 ​ 首先，为了跟踪（track），或者说管理执行上下文。有了执行上下文栈的概念。 The execution context stack is used to track execution contexts. The running execution context is always the top element of this stack. ​ 相信大家对这个栈的疑问并不是很大，只需要明白这里又多了个当前执行上下文（或者就叫正在运行的执行上下文，字太多了，后文就用当前执行上下文称呼）的概念，在浏览器中是由一个记录当前执行状态的指针ESP所指向的，通过控制该指针，来销毁栈中的执行上下文（没指向就能用下一个执行上下文直接覆盖，并由垃圾回收器回收该执行上下文中使用的内存，关于垃圾回收，在找到官方解释之后我也会总结）。 ​ 好家伙，一个执行上下文整出这么多事儿，看样子我还需要其他信息才能知道他是啥！！ An execution context contains whatever implementation specific state is necessary to track the execution progress of its associated code. ​ 。。。这里直译就可以了： 在实现中，执行上下文包含跟踪相关代码的执行进度所必需的，任何特定状态。 ​ 说了等于没说。。。那不然说这是规范呢！但人还是有要求的： 其中构成上，至少有六个部分（我们知道，当我们尝试理解一个新事物的时候，新事物的构成并不一定是最重要的，因为我们可能并没有达到需要了解他的地步，例如，牛奶。）： code evaluation state，Function，Realm，ScriptOrModule，LexicalEnvironment，VariableEnvironment 简单的说下我的理解。 通过一些component来构成一个执行上下文，描述了其关联的代码所能使用的作用域（执行上下文）的（广义上的）变量（LexicalEnvironment和VariableEnvironment）；这个执行上下文本身的跟踪（评估）对象（Function Component的值），等等。 此处我们给出规范中的介绍，其他的不再过多的解释。 简而言之， An execution context contains whatever implementation specific state is necessary to track the execution progress of its associated code. Whatever is necessary. \\（￣︶￣）/ 类比于牛奶，对于执行上下文的构成我们不需要了解的很深，我们将剩下的精力集中在它的运行机制上，然而也很简单。 前面说了，有一个执行上下文栈来维护执行上下文。栈顶的执行上下文就是当前执行上下文。 比如说浏览器中，代码刚开始运行，负责运行JS的线程就通过某些算法（用来Enqueue Jobs）取得任务，创建第一个执行上下文，然后开始执行，此时也是当前执行上下文，每当遇到新的Function、Modul/Script时，就会创建新的执行上下文，并挂起当前的执行上下文（若没执行完的话），即新执行上下文成为栈顶，当新的执行上下文关联的代码执行完毕，即出栈后，则重新恢复刚刚挂起的执行上下文。 值得我们注意的只是，每个当前执行上下文的作用域，都包含了栈内的其他执行上下文中的作用域。 好，执行上下文没了。就这？就这。 作用域链&amp;变量环境、词法环境前面说，JS中通过执行上下文通过来描述作用域。而作用域链这个概念呢，在规范中是不存在的。所以我斗胆自己总结了一下（逃）。 作用域链，就是当前执行上下文的两个环境记录（Environment Record，一种记录类型），即词法环境（LexicalEnvironment），和变量环境（VariableEnvironment）以及它们所指向的其他环境记录。 这些环境记录，记录了所有的变量、函数、类、模块，对象，内置全局对象，内置全局对象的属性，以及顶级声明与名称（标识符）的绑定关系。简单的来说，即静态作用域（静态作用域与动态作用域的概念。。。下面也会补）中所有的名称（标识符）绑定。 这两种环境记录呢，就是前面所提的Record类型，因为其内部的[[OuterEnv]]字段，指向了其他（外部）执行上下文的环境记录（没有外部环境记录的，该字段值就为null），很容易抽象成链条的形式，所以被称为作用域链。 这两种环境记录还可以稍加区别，如，”var声明的变量存在变量环境中，let、const声明的变量存在词法环境中“——该结论来源于李兵大佬关于浏览器的一门课程，关于浏览器，推荐有条件的同学看这系列文章，之后我也会做相关的学习记录。 对以上概念如有疑问，详见规范的8.1节。 闭包在？先看我的理解。（洗脑洗脑洗脑） 闭包，是一种，能够捕获标识符（广义上的变量），携带参数，并且以类似函数的调用方式（closure(arg1, arg2)）调用，的规范类型。 个人认为，重要的就只有两部分。 一，咳咳，它是一种规范类型（Specification Type），这是毋庸置疑的，毕竟规范里写的明明白白。（所以我们就像对待Record那样对待它就行啦，如果特别感兴趣，再去思考内存中的闭包到底是怎样的罢——函数¿） 二，它能够捕获变量，一旦闭包捕获了变量，那这些变量就不会无缘无故的消失（指垃圾回收），这也是闭包在众多场景出现的主要原因。规范中的例子也表明了这一点： Abstract Closures are created inline as part of other algorithms, shown in the following example. 1.Let addend be 41. 2.Let closure be a new Abstract Closure with parameters (x) that captures addend and performs the following steps when called: ​ Return x + addend. 3.Let val be closure(1). 4.Assert: val is 42. 在？感兴趣的还可以看看规范对闭包的描述： The Abstract Closure specification type is used to refer to algorithm steps together with a collection of values. 抽象闭包规范类型用于引用算法步骤和值的集合。 闭包的概念，实际上我认为并不难，难的另有所在。 其中之一，就是… 闭包的产生条件这一点各有各的说法，在这里我推荐一个我认为讲的很清楚的文章（波神的公众号是宝藏哦~） 引用文章中的一句话。 对于有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。 另外的难点就是…… 闭包的出现场景（闭包这块对于我来说还是太难啦，所以这部分就当分享与交流咯~） 在需要清除setInterval的地方。 我们知道，每个setInterval一旦启动，就需要手动清除，并且只能在其回调函数内清除（不然呢不然呢不然呢）。这里的回调函数因为捕获了外部的定时器标识，而生成了闭包。 每一个中间模块（即接受别的模块，导出用到了这个模块的新的模块）。 这里引用一段大神的话。 本质上，JavaScript中并没有自己的模块概念，我们只能使用函数/自执行函数来模拟模块。 现在的前端工程中（ES6的模块语法规范），使用的模块，本质上都是函数或者自执行函数。 （webpack等打包工具会帮助我们将其打包成为函数） 推荐看大神的这篇文章，相信会有意想不到的收货。 ……（想不到了！！！我好菜。。） 闭包到这里就先告一段落。 其他概念变量对象（？）与活动（函数）对象不知道从什么时候起，有了变量对象和函数对象的概念，应该是一些教材里面的，由于我没有看过，，所以这些概念我也只能从规范中寻找。。。 结果只找到了活动（函数）对象的概念。就一句话： The value of the Function component of the running execution context is also called the active function object. 即，当前执行上下文的Function Component的值。这个值，在前面的图片上有说，就是当前执行上下文评估的那个函数对象。原话是： If this execution context is evaluating the code of a function object, then the value of this component is that function object. If the context is evaluating the code of a Script or Module, the value is null. 然而我没有找到变量对象的概念（暂时），所以我就结合起来理解，将他理解为非当前执行上下文的Function Component的值，即非当前执行上下文所评估的函数对象。 名称绑定&amp;绑定关系——值模型、引用模型这个概念是对所有编程语言来说的~ 所谓的名称绑定（Name binding），是指将名字和他所要代表的实体联系在一起。通常在编程语言中，名称被称为标识符。一般来说，名称绑定的实体是可以被更换的，这样的名称就是大家熟知的变量，而被绑定的实体则是变量值，通过赋值来更换变量值。 其中，变量，根据其与绑定的值的关系，可以分为值模型和引用模型。 这两种模型的差异导致的主要影响是：一个变量的值被赋予另一个变量，应用值模型时，值会被复制，副本保存在被复制的变量中，两者就此互不相关；而应用引用模型师，只是指针被复制，赋予第二个变量，数据仍然只有一份，若是其中一方修改了指针指向的数据，另一方也能看到同样的变化。 因此这两个模型，前者更安全，后者对体量巨大的数据则节省了复制的时间和空间。采用引用模型的数据，被称为引用类型，而采用值模型的数据，则被称为值类型。 JavaScript的参数传递方式JavaScript属于动态类型的语言，因为这类语言可以被赋予任何类型的值，所以基本都采用引用模型，JavaScript亦是如此。 但是值得一提的是，数据的值类型、引用类型和参数传递的两种方式——按值传递、按引用传递，是不同的概念。 按值传递将实际参数的值复制到函数的形参中，两者互不干扰；而按引用传递是将实际参数的引用传递给形参，相当于在函数内部进行了一次新的名称绑定。 对于JavaScript的参数传递方式，普遍存在两种声音。但实际上，JavaScript采用的是按值传递的方式。 在JavaScript中的所有数据都是引用类型的，只是通过创建新的实例的方式，来保证数字、字符串等数据类型的不可变性。（例如，新建一个基本数据类型，你会发现它也能调用方法） 对于引用类型的数据，按值传递可以说是自然地选择。函数对形参的改变，会实际反映到实参上（搞清楚形参与实参哟），这一点与值类型的按引用传递相同；但函数内无法更换实参的引用，对形参重新赋值，仅仅是更换了形参的引用，对实参没有影响，这一点却和值类型的按值传递相同。 静态作用域与动态作用域。。。桥豆麻袋，待我翻下书再补。 差点忘了this由于JavaScript自己的执行上下文，闭包等，并不能做到一个需求——在对象内部的方法中，人为地指定使用对象内部的某个属性。所以，有了this机制。 这样想来，我们大可不必将作用域链与this扯到一起。 所以，一般情况下，this 的作用就是在对象的方法中，指向对象本身，方便开发者使用对象的属性。 然鹅，为什么要说一般呢（可达鸭眉头一皱，发现事情并不简单(｡•ˇ‸ˇ•｡)）。 由于设计缺陷（斗胆），在非严格模式下，this在普通函数中仍然存在，并指向window对象，违背了其出现的意义。 而且，由于this的绑定是在创建执行上下文时进行的，因此导致了另一个问题——在对象方法中嵌套使用函数，其内部this的指向会违背使用直觉。 （对于this具体的绑定过程，只是我的推断，但并未验证，望大佬指点。）每当创建函数时，就会创建新的执行上下文，进行this的绑定，当其顺着作用域链查找上临近的一个外层执行上下文时，发现自己是在对象当中创建的，则将this绑定为这个对象；若临近的外层执行上下文中没发现对象，则将this绑定为window或undefined 因此在对象的方法中，若继续嵌套函数，因为创建新的执行上下文时，临近的执行上下文内并没有对象，所以其内部的this将不再指向对象，发生了重新绑定，变为了window（非严格模式）或undefined。 阿这，好累啊。。。感谢观看","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"ECMAScript2021","slug":"ECMAScript2021","permalink":"/tags/ECMAScript2021/"},{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"抽象操作之==比较","slug":"抽象操作之==比较","date":"2020-06-25T14:56:22.000Z","updated":"2020-07-17T09:07:53.990Z","comments":true,"path":"post/6251.html","link":"","permalink":"/post/6251.html","excerpt":"","text":"我不知道的ECMAScript2021——‘==’比较结论简单总结一下==比较的算法规则： 首先==两边的操作数是否是同一类型，如果是，则同===比较。 两个操作数都是基本数据类型（Number，String，Boolean，BigInt，Symbol）： 一个 操作数是Numeric（Number、BigInt），则将另外一个操作数转成对应的数值类型来比较。 一个操作数是Boolean，则将Boolean转化成Number，再进行比较。 一个操作数是对象，则通过ToPrimitive ( input [ , PreferredType ] )，将对象转换成基本数据类型再比较。 经过转换，很多最后都会变成数值之间的比较，如果mathematical value的值相等，那返回true，否则为false。需要注意的是，NaN, +∞, -∞的出现，就代表了整个比较的结果为false。 结论来源： 引自 ‘Draft ECMA-262 / June 23, 2020 ECMAScript® 2021 Language Specification’ 7.2.15 Abstract Equality ComparisonThe comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows: If Type(x) is the same as Type(y), then Return the result of performing Strict Equality Comparison x === y. If x is null and y is undefined, return true. If x is undefined and y is null, return true. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y). If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y. If Type(x) is BigInt and Type(y) is String, then Let n be ! StringToBigInt(y). If n is NaN, return false. Return the result of the comparison x == n. If Type(x) is String and Type(y) is BigInt, return the result of the comparison y == x. If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y. If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y). If Type(x) is either String, Number, BigInt, or Symbol and Type(y) is Object, return the result of the comparison x == ? ToPrimitive(y). If Type(x) is Object and Type(y) is either String, Number, BigInt, or Symbol, return the result of the comparison ? ToPrimitive(x) == y. If Type(x) is BigInt and Type(y) is Number, or if Type(x) is Number and Type(y) is BigInt, then If x or y are any of NaN, +∞, or -∞, return false. If the mathematical value of x is equal to the mathematical value of y, return true; otherwise return false. Return false. 注意事项需要注意上文中的！与？，并不是JS的操作符，而是规范中运行时语义（Runtime Semantic）——ReturnIfAbrupt的shorthand。其中！与？的区别主要在调用语义处返回的Completion Record的类型（[[Type]]）上，在这里讨论的==比较中应该没什么影响，详情见规范的第五章第二节和第七章第二节： Invocations of abstract operations and syntax-directed operations that are prefixed by ? indicate that ReturnIfAbrupt should be applied to the resulting Completion Record. Similarly, prefix ! is used to indicate that the following invocation of an abstract or syntax-directed operation will never return an abrupt completion and that the resulting Completion Record‘s [[Value]] field should be used in place of the return value of the operation. ToPrimitive ( input [ , PreferredType ] )的转化规则如下，仅需要注意，其中用到的toString等函数可能是被内置覆盖了的，如[].toString()，其他的就不做更多的解读了： 7.1.1 ToPrimitive ( input [ , PreferredType ] )The abstract operation ToPrimitive takes argument input and optional argument PreferredType. It converts its input argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint PreferredType to favour that type. It performs the following steps when called: Assert: input is an ECMAScript language value. If Type(input) is Object, then If PreferredType is not present, let hint be “default“. Else if PreferredType is hint String, let hint be “string“. Else, Assert: PreferredType is hint Number. Let hint be “number“. Let exoticToPrim be ? GetMethod(input, @@toPrimitive). If exoticToPrim is not undefined, then Let result be ? Call(exoticToPrim, input, « hint »). If Type(result) is not Object, return result. Throw a TypeError exception. If hint is “default“, set hint to “number“. Return ? OrdinaryToPrimitive(input, hint). Return input. 7.1.1.1 OrdinaryToPrimitive ( O, hint )The abstract operation OrdinaryToPrimitive takes arguments O and hint. It performs the following steps when called: Assert: Type(O) is Object. Assert: Type(hint) is String and its value is either “string“ or “number“. If hint is “string“, then Let methodNames be « “toString“, “valueOf“ ». Else, Let methodNames be « “valueOf“, “toString“ ». For each name in methodNames in List order, do Let method be ? Get(O, name). If IsCallable(method) is true, then Let result be ? Call(method, O). If Type(result) is not Object, return result. Throw a TypeError exception.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"ECMAScript2021","slug":"ECMAScript2021","permalink":"/tags/ECMAScript2021/"},{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-02T03:11:11.000Z","updated":"2020-06-22T14:10:12.504Z","comments":true,"path":"post/3eeb.html","link":"","permalink":"/post/3eeb.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}